
# This script is used to generate the www/api.wiki page from comments in
# the source file zipvfs.h. It should be run as follows:
#
#    tclsh ./tools/updateapi.tcl ./src/zipvfs.h > www/api.wiki
#
# before committing changes to API comments in file zipvfs.h.
#

set document_preamble {
<title>Zipvfs C API Reference</title>
<br note="
  DO NOT EDIT!!! 
  DO NOT EDIT!!! 
  DO NOT EDIT!!! 
  This document is generated by script tools/updateapi.tcl.
  DO NOT EDIT!!! 
  DO NOT EDIT!!! 
  DO NOT EDIT!!! 
">
<center><h1>Zipvfs C API Reference</h1></center>

<p>
This document is a reference guide for the C API used by zipvfs applications.
The API consists of C functions to create and destroy zipvfs VFS instances,
a C function to translate an error code to an English language error message,
and a list of file-control operations supported by SQLite database handles
that use a zipvfs VFS. One of the file-control operations reports on the
current usage of space within a zipvfs database file by populating the
fields of a C structure - this structure is also described below.

}

set document_text ""

proc put_section {} {
  global S

  if {$::state != "off"} {

    regexp {^([^( ]*)} $S(heading) -> id
    set id [string tolower [string map {- _} $id]]
    if {$id == "file"} {set id filespace}

    append ::document_text "<h2 id=$id>$S(heading)</h2>\n"
    append ::document_text "<blockquote><pre>$S(code)</pre></blockquote>\n"
    append ::document_text "$S(text)"

    append ::document_toc "<li><a href=\"#$id\">$S(heading)</a>\n"
  }

  set S(heading) ""
  set S(code) ""
  set S(text) ""
}

# Process the command line arguments.
#
if {[llength $argv]!=1} {
  puts stderr "Usage: $argv0 <path to zipvfs.h>"
  exit -1
}
set zipvfsh [lindex $argv 0]
set fd [open $zipvfsh]

# The $state variable may be set to one of:
#
#   off
#   on
#   table
#   deflist
#
set state off

while {![eof $fd]} {
  set line [gets $fd]

  switch -regexp -- $line {
    {^/\* *$} { # no-op }
    {^\*/ *$} { # no-op }
    {^ *$} { # no-op }

    {^\*\* CAPI: .*$} {
      put_section
      regexp {.*CAPI: (.*)} $line -> S(heading)
      set state on
    }
    {.*ENDOFAPI.*} {
      put_section
      set state off
    }

    {^\*\* *[^ ]*: *$} {
      regexp {( *)([^ ]*):} $line -> ws title
      if {$state == "on"} {
        if {[string length $ws] > 1} {
          append S(text) <table>
          set state table
        } else {
          append S(text) <dl>
          set state deflist
        }
      }
      if {$state == "table"} {
        append S(text) "<tr><td valign=top>$title<td>"
      }
      if {$state == "deflist"} {
        append S(text) <dt\ id="$title">$title<dd>
      }
    }

    {^\*\* *$} {
      if {$state == "on" || $state=="deflist"} {
        append S(text) <p>
      }
    }

    {^\*\*.*$} {
      if {$state != "off"} {
        regexp {^\*\*( *)(.*)} $line -> ws text

        if {$state == "table" && [string length $ws]<=1} {
          append S(text) </table><p>
          set state on
        }
        if {$state == "deflist" && [string length $ws]<=1} {
          append S(text) </dl><p>
          set state on
        }

        if {$state == "on" && [string length $ws]>=3} {
          append S(text) <blockquote><pre>$text</blockquote></pre>
        } else {
          append S(text) $text
        }

        append S(text) "\n"
      }
    }

    default {
      if {$state != "off"} {
        if {$state == "table"} { append S(text) </table> }
        if {$state == "deflist"} { append S(text) </dl> }
        set state on
      }
      if {$state == "on"} {
        append S(code) $line
        append S(code) "\n"
      }
    }
  }
}

close $fd

puts $document_preamble
puts <ol>
puts $document_toc
puts </ol>
puts $document_text
