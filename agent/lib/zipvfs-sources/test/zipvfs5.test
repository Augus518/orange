
# This file contains miscellaneous test cases for zipvfs.
#

set testdir $env(SQLITE_TEST_DIR)
source $testdir/tester.tcl
set ::testprefix zipvfs5
db close

zip_register "" 0
rle_register "" 0
noop_register "" 0
padded_register "" 0

sqlite3 db test.db -vfs zip
set hdrfield(iFreeSlot)     {0  8}
set hdrfield(iDataStart)    {8  8}
set hdrfield(iDataEnd)      {16 8}
set hdrfield(iGapStart)     {24 8}
set hdrfield(iGapEnd)       {32 8}
set hdrfield(iSize)         {40 8}
set hdrfield(nFreeSlot)     {48 8}
set hdrfield(nFreeByte)     {56 8}
set hdrfield(nFreeFragment) {64 8}
set hdrfield(pgsz)          {72 4}
set hdrfield(iVersion)      {76 4}

proc read_header_field {zipfile field} {
  global hdrfield

  set fd [open $zipfile]
  fconfigure $fd -encoding binary -translation binary
  
  set off [lindex $hdrfield($field) 0]
  set sz  [lindex $hdrfield($field) 1]
  incr off 100

  seek $fd $off
  set data [read $fd $sz]
  close $fd
  if {$sz==4} { binary scan $data I ret }
  if {$sz==8} { binary scan $data W ret }

  return $ret
}

proc write_header_field {zipfile field iVal} {
  global hdrfield
  
  set off [lindex $hdrfield($field) 0]
  set sz  [lindex $hdrfield($field) 1]
  incr off 100

  if {$sz==4} { set data [binary format I $iVal] }
  if {$sz==8} { set data [binary format W $iVal] }

  set fd [open $zipfile r+]
  fconfigure $fd -encoding binary -translation binary
  seek $fd $off
  puts -nonewline $fd $data
  close $fd

  return ""
}

proc find_page {dbfile pgno iOffVar nByteVar} {
  upvar $iOffVar iOff
  upvar $nByteVar nByte

  set entryoff [expr {200 + ($pgno-1) * 8}]
  set entry [hexio_read $dbfile $entryoff 8]

  set iOff [expr {
      ([hexio_get_int [string range $entry 0 1]] << 32)
    + ([hexio_get_int [string range $entry 2 9]])
  }]

  set nByte [expr [hexio_get_int [string range $entry 10 15]] >> 7]
}

# Return a string based on the integer value passed as an argument.
#
proc int_to_string {i} {
  set integers [list zero one two three four five six seven eight nine]
  set out [list]
  lappend out [lindex $integers [expr ($i/1000)%10]]
  lappend out [lindex $integers [expr ($i/100)%10]]
  lappend out [lindex $integers [expr ($i/10)%10]]
  lappend out [lindex $integers [expr ($i/1)%10]]
}

proc populate_db_1 {db} {
  $db eval { CREATE TABLE t1(a, b, UNIQUE(a, b)) }
  for {set i 0} {$i < 100} {incr i} {
    set a [int_to_string $i]
    set b [int_to_string [expr 100-$i]]
    $db eval { INSERT INTO t1 VALUES($a, $b) } 
  }
}

#-------------------------------------------------------------------------
# Test that it is not possible to use journal_mode=wal with zipvfs.
#
do_execsql_test 1.0 {
  PRAGMA auto_vacuum = off;
  CREATE TABLE x1(a, b); INSERT INTO x1 VALUES('a', 'b');
  CREATE TABLE x2(a, b); INSERT INTO x2 VALUES('c', 'd');
}

do_catchsql_test 1.1 { 
  PRAGMA journal_mode = Wal
} {1 {journal_mode=Wal may not be used with zipvfs}}
do_execsql_test  1.2 { SELECT * FROM x1 } {a b}
do_execsql_test  1.3 { SELECT * FROM x2 } {c d}
do_test          1.4 { file exists test.db-wal } 0

db close

#-------------------------------------------------------------------------
# Test the ZIPVFS_CTRL_WRITE_HOOK debugging function. Since this function
# is intended for debugging only, it is only tested to improve code 
# coverage metrics. 
#
proc xWriteHook {iPg nByte} { lappend ::pages $iPg }

do_test 2.0 {
  sqlite3 db test.db -vfs zip
  zip_control db main write_hook xWriteHook
  set ::pages [list]
  execsql { UPDATE x2 SET a = 'e' }
  lsort -integer $::pages
} {1 3}
do_test 2.1 {
  zip_control db main write_hook ""
  set ::pages [list]
  execsql { UPDATE x2 SET a = 'e' }
  lsort -integer $::pages
} {}
do_test 2.2 {
  zip_control db main write_hook xWriteHook
  set ::pages [list]
  execsql { UPDATE x1 SET a = 'f' }
  lsort -integer $::pages
} {1 2}
do_test 2.3 { db close } {}

#-------------------------------------------------------------------------
# Test the ZIPVFS_CTRL_DETECT_CORRUPTION debugging function.
#
forcedelete test.db
sqlite3 db test.db -vfs zip
do_execsql_test 3.1.1 {
  PRAGMA page_size = 512;
  CREATE TABLE t1(a, b);
  INSERT INTO t1 VALUES(randomblob(200), zeroblob(200));
  INSERT INTO t1 SELECT randomblob(200+rowid), zeroblob(200-rowid) FROM t1;
  INSERT INTO t1 SELECT randomblob(200+rowid), zeroblob(200-rowid) FROM t1;
  INSERT INTO t1 SELECT randomblob(200+rowid), zeroblob(200-rowid) FROM t1;
  INSERT INTO t1 SELECT randomblob(200+rowid), zeroblob(200-rowid) FROM t1;
  INSERT INTO t1 SELECT randomblob(200+rowid), zeroblob(200-rowid) FROM t1;
  INSERT INTO t1 SELECT randomblob(200+rowid), zeroblob(200-rowid) FROM t1;
  INSERT INTO t1 SELECT randomblob(200+rowid), zeroblob(200-rowid) FROM t1;
  INSERT INTO t1 SELECT randomblob(200+rowid), zeroblob(200-rowid) FROM t1;
}
do_test 3.1.2 {
  db close
  set fd [open test.db a+]
  seek $fd 1000
  puts $fd "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
  close $fd
  sqlite3 db test.db -vfs zip
  catchsql { SELECT count(*) FROM sqlite_master }
} {0 1}
do_test 3.1.3 {
  zip_control db main detect_corruption 1
  catchsql { SELECT count(*) FROM sqlite_master }
} {1 {disk I/O error}}

db close
forcedelete test.db
sqlite3 db test.db -vfs zip
do_execsql_test 3.2.1 {
  PRAGMA page_size = 1024;
  PRAGMA secure_delete = 1;
  BEGIN;
    CREATE TABLE t1(x PRIMARY KEY);
    INSERT INTO t1 VALUES(randomblob(800));
    INSERT INTO t1 VALUES(randomblob(800));
    INSERT INTO t1 VALUES(randomblob(800));
  COMMIT;
} {1}
do_execsql_test 3.2.2 { UPDATE t1 SET x = randomblob(900) }
db close
do_test 3.2.3 {
  set freeslot [read_header_field test.db iFreeSlot]

  set off [expr $freeslot+4+6]
  while { [hexio_read test.db [expr $off+7] 1] == "01" } {
    incr off 8
  }
  hexio_write test.db [expr $off+7] 01

  sqlite3 db test.db -vfs zip
  zip_control db main detect_corruption 1
  catchsql { SELECT count(*) FROM t1 }
} {1 {disk I/O error}}

#-------------------------------------------------------------------------
# Test that corruption is correctly detected if when zipvfs tries to 
# remove a free-slot from the start of the data area the free-slot is not
# present in the free-list.
#
db close
forcedelete test.db
sqlite3 db test.db -vfs zip
do_execsql_test 4.1 {
  PRAGMA page_size = 8192;
  PRAGMA secure_delete = 1;
  CREATE TABLE t1(x);
} {1}
do_test 4.2 {
  for {set i 2} {$i<=30} {incr i} {
    execsql "CREATE TABLE t$i (x)"
  }
  execsql {PRAGMA page_count}
} {32}
db close


#-------------------------------------------------------------------------
# Test that a backup between two zipvfs databases works when the source
# database is empty.
#
do_test 5.1 {
  forcedelete test.db1 test.db2
  sqlite3 db1 test.db1 -vfs zip
  sqlite3 db2 test.db2 -vfs zip
  execsql {
    CREATE TABLE t1(a,b);
    INSERT INTO t1 VALUES(random(), randomblob(800));
    INSERT INTO t1 VALUES(random(), randomblob(800));
    INSERT INTO t1 SELECT random(), randomblob(800) FROM t1;
    INSERT INTO t1 SELECT random(), randomblob(800) FROM t1;
    INSERT INTO t1 SELECT random(), randomblob(800) FROM t1;
    INSERT INTO t1 SELECT random(), randomblob(800) FROM t1;
    SELECT count(*) FROM t1;
  } db2
} {32}

do_test 5.2 {
  sqlite3_backup B db2 main db1 main
  B step 0
  B finish
} {SQLITE_OK}

zip_control db2 main detect_corruption 1
do_test 5.3 { 
  execsql { SELECT name FROM sqlite_master } db2
} {}

db1 close
db2 close

#-------------------------------------------------------------------------
# Test that an incremental backup from a zipvfs database works.
#
do_test 6.1 {
  forcedelete test.db1 test.db2
  sqlite3 db1 test.db1 -vfs zip
  sqlite3 db2 test.db2
  execsql {
    CREATE TABLE t1(a,b);
    INSERT INTO t1 VALUES(random(), randomblob(800));
    INSERT INTO t1 VALUES(random(), randomblob(800));
    INSERT INTO t1 SELECT random(), randomblob(800) FROM t1;
    INSERT INTO t1 SELECT random(), randomblob(800) FROM t1;
    INSERT INTO t1 SELECT random(), randomblob(800) FROM t1;
    INSERT INTO t1 SELECT random(), randomblob(800) FROM t1;
    SELECT count(*) FROM t1;
  } db1
} {32}

do_test 6.2 {
  sqlite3_backup B db2 main db1 main
  set rc ""
  while {$rc != "SQLITE_DONE"} { set rc [B step 10] }
  B finish
} {SQLITE_OK}

do_test 6.3 { 
  set sum1 [db1 eval {SELECT md5sum(a, b) FROM t1}]
  set sum2 [db2 eval {SELECT md5sum(a, b) FROM t1}]
  expr {$sum1 == $sum2}
} {1}
db1 close
db2 close

#-------------------------------------------------------------------------
# Another corruption case. Test the outcome of a record uncompressing to
# something other than the page-size of the database file. Do this by
# writing a record from a database with pgsz=512 into a database with
# pgsz=1024.
#
do_test 7.1 {
  forcedelete test.db1 test.db2
  sqlite3 db1 test.db1 -vfs zip
  sqlite3 db2 test.db2 -vfs zip

  execsql {
    PRAGMA page_size=512;
    PRAGMA auto_vacuum=0;
    CREATE TABLE t1(x);
  } db1
  execsql {
    PRAGMA page_size=1024;
    PRAGMA auto_vacuum=0;
    CREATE TABLE t1(x);
  } db2

  db1 close
  db2 close

  set pgmapentry [hexio_read test.db1 208 8]
  set offset [hexio_get_int [string range $pgmapentry 2 9]]
  set size   [expr 1 + [hexio_get_int [string range $pgmapentry 10 13]]]
  set newoff [file size test.db2]
  set newentry "00"
  append newentry [hexio_render_int32 $newoff]
  append newentry [string range $pgmapentry 10 end]

  set data [hexio_read test.db1 $offset [expr $size+4]]
  hexio_write test.db2 208 $newentry
  hexio_write test.db2 $newoff $data
  hexio_write test.db2 2047 00

  sqlite3 db test.db2 -vfs zip
  catchsql { SELECT * FROM t1 } db
} {1 {disk I/O error}}
db close

#-------------------------------------------------------------------------
# Test that everything appears to work when slots have more than 255 bytes
# of padding.
#
do_test 8.1 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip

  # Set up zipvfs so that there is no effective limit on padding and 
  # free-slots are reused as aggressively as possible.
  zip_control db main max_frag 10000
  zip_control db main max_free 0

  execsql { CREATE TABLE t1(x,y) }
  for {set i 0} {$i < 900} {incr i} {
    execsql { INSERT INTO t1 VALUES(randomblob(900), zeroblob(0)) }
  }
  zip_control db main integrity_check 
} {}
do_test 8.2 {
  execsql { UPDATE t1 SET x=randomblob(900-rowid), y=zeroblob(rowid) }
  zip_control db main integrity_check 
} {}
do_test 8.3 {
  execsql { UPDATE t1 SET x=zeroblob(900), y=zeroblob(0) }
  zip_control db main integrity_check 
} {}
do_test 8.4 {
  set bytes [expr [file size test.db] / 2]
  zip_control db main compact $bytes 
  zip_control db main integrity_check 
} {}
do_test 8.5 {
  set bytes [file size test.db]
  zip_control db main compact $bytes 
  zip_control db main integrity_check 
} {}

#-------------------------------------------------------------------------
# Check that ZIPVFS_CTRL_INTEGRITY_CHECK detects various types of 
# corruption.
#
do_test 9.1 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip

  execsql {
    CREATE TABLE t1(x, y);
    INSERT INTO t1 VALUES('a value for x', 'a value for y');
    INSERT INTO t1 VALUES('another value for x', 'and another value for y');
  }
  db_save_and_close
} {}
do_test 9.2 {
  find_page test.db 2 iOff nByte
  hexio_write test.db $iOff 00000000
  sqlite3 db test.db -vfs zip
  catch { zip_control db main integrity_check } msg
  set msg
} {disk I/O error}

do_test 9.3 {
  db close
  db_restore
  find_page test.db 2 iOff nByte
  hexio_write test.db $iOff 00000001
  sqlite3 db test.db -vfs zip
  catch { zip_control db main integrity_check } msg
  set msg
} {disk I/O error}

do_test 9.4 {
  db close
  db_restore
  hexio_write test.db [expr 208+5] 7FFF
  sqlite3 db test.db -vfs zip
  catch { zip_control db main integrity_check } msg
  set msg
} {disk I/O error}

do_test 9.5 {
  db close
  db_restore
  hexio_write test.db [expr 100+48] 0010000000000000
  sqlite3 db test.db -vfs zip
  catch { zip_control db main integrity_check } msg
  set msg
} {disk I/O error}

do_test 9.6 {
  db close
  db_restore
  hexio_write test.db [expr 100+56] 0010000000000000
  sqlite3 db test.db -vfs zip
  catch { zip_control db main integrity_check } msg
  set msg
} {disk I/O error}

do_test 9.7 {
  db close
  db_restore
  hexio_write test.db [expr 100+64] 0010000000000000
  sqlite3 db test.db -vfs zip
  catch { zip_control db main integrity_check } msg
  set msg
} {disk I/O error}

#-------------------------------------------------------------------------
# Check that corruption is detected when moving a page to the end of the
# file to make room to extend the page-map.
#
do_test 10.1 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  execsql {
    PRAGMA page_size = 1024;
    PRAGMA auto_vacuum = 0;
    BEGIN;
      CREATE TABLE t1(x);
      INSERT INTO t1 VALUES(randomblob(30*1010));
    COMMIT;
    CREATE TABLE t2(x);
    PRAGMA page_count;
  }
} {32}
do_test 10.2 {
  db close
  hexio_write test.db [expr {200 + 32*8}] 00000044
  sqlite3 db test.db -vfs zip
  catchsql { CREATE TABLE t3(x) }
} {0 {}}

#-------------------------------------------------------------------------
# Check commit and rollback using various journal-modes.
#
foreach {tn mode} {
  1    delete
  2    truncate
  3    off
  4    memory
} {
  catch {db close}
  forcedelete test.db

  sqlite3 db test.db -vfs zip
  execsql {
    PRAGMA cache_size = 5;
    PRAGMA auto_vacuum = 1;
    CREATE TABLE t1(x, y);
    CREATE INDEX i1 ON t1(x, y);
    CREATE INDEX i2 ON t1(y, x);

    INSERT INTO t1 VALUES(randomblob(800), zeroblob(0));
    INSERT INTO t1 SELECT randomblob(800-rowid), zeroblob(rowid) FROM t1;
    INSERT INTO t1 SELECT zeroblob(800-rowid), randomblob(rowid) FROM t1;
    INSERT INTO t1 SELECT randomblob(800-rowid), zeroblob(rowid) FROM t1;
    INSERT INTO t1 SELECT zeroblob(800-rowid), randomblob(rowid) FROM t1;
    INSERT INTO t1 SELECT randomblob(800-rowid), zeroblob(rowid) FROM t1;
    INSERT INTO t1 SELECT zeroblob(800-rowid), randomblob(rowid) FROM t1;
    INSERT INTO t1 SELECT randomblob(800-rowid), zeroblob(rowid) FROM t1;
    INSERT INTO t1 SELECT zeroblob(800-rowid), randomblob(rowid) FROM t1;
  }

  execsql " PRAGMA journal_mode = $mode "
  do_execsql_test 11.$tn.1 {
    BEGIN;
      UPDATE t1 SET x = randomblob(rowid), y = randomblob(rowid) WHERE x%3;
    COMMIT;
  }

  set sum [db one {SELECT md5sum(x, y) FROM t1}]
  do_execsql_test 11.$tn.2 {
    BEGIN;
      UPDATE t1 SET x = randomblob(rowid), y = randomblob(rowid) WHERE x%3;
    ROLLBACK;
  }
  do_execsql_test 11.$tn.3 { SELECT md5sum(x, y) FROM t1 } $sum
  do_execsql_test 11.$tn.4 { PRAGMA integrity_check } ok
  do_catchsql_test 11.$tn.5 {
    PRAGMA journal_mode=WAL;
  } {1 {journal_mode=WAL may not be used with zipvfs}}
  do_catchsql_test 11.$tn.6 {
    PRAGMA journal_mode=PERSIST;
  } {1 {journal_mode=PERSIST may not be used with zipvfs}}
}

#-------------------------------------------------------------------------
# The following block of tests test something that doesn't work. Changing
# the page-size during a backup or VACUUM operation. If these tests start
# failing the documentation needs to be updated.
#
foreach {tn pgsz1 pgsz2} {
  1 512  4096
  2 4096 512
} {
  catch {db close}
  forcedelete test.db

  sqlite3 db test.db -vfs zip
  execsql "PRAGMA page_size = $pgsz1"
  execsql {
    CREATE TABLE t1(x, y);
    CREATE INDEX i1 ON t1(x, y);
    CREATE INDEX i2 ON t1(y, x);

    INSERT INTO t1 VALUES(randomblob(800), zeroblob(0));
    INSERT INTO t1 SELECT randomblob(800-rowid), zeroblob(rowid) FROM t1;
    INSERT INTO t1 SELECT zeroblob(800-rowid), randomblob(rowid) FROM t1;
    INSERT INTO t1 SELECT randomblob(800-rowid), zeroblob(rowid) FROM t1;
  }

  do_test 12.$tn.1 {
    execsql "PRAGMA page_size = $pgsz2"
    set rc1 [catch { execsql VACUUM }]
    set rc2 [catch { execsql {PRAGMA integrity_check} }]
    expr $rc1+$rc2
  } 1
}

#-------------------------------------------------------------------------
# Check that read-only database files appear to work.
#
do_test 13.1 {
  catch { db close }
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  execsql {
    CREATE TABLE t1(a, b);
    INSERT INTO t1 VALUES(1, 2);
  }
  db close
  catch {file attributes test.db -permissions r--------}
  catch {file attributes test.db -readonly 1}

  sqlite3 db test.db -vfs zip
  execsql { SELECT * FROM t1 }
} {1 2}
do_catchsql_test 13.2 {
  INSERT INTO t1 VALUES(3, 4);
} {1 {attempt to write a readonly database}}

#-------------------------------------------------------------------------
# Check that attempting to switch to WAL mode always fails.
#
do_test 14.1 {
  catch { db close }
  catch {file attributes test.db -permissions rw-rw-rw-}
  catch {file attributes test.db -readonly 0}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  execsql {
    CREATE TABLE t1(a, b);
    INSERT INTO t1 VALUES(1, 2);
  }
} {}
do_catchsql_test 14.2 { 
  PRAGMA journal_mode = WAL 
} {1 {journal_mode=WAL may not be used with zipvfs}}
do_catchsql_test 14.3 { 
  PRAGMA locking_mode = EXCLUSIVE;
} {1 {locking_mode=exclusive may not be used with zipvfs}}
do_execsql_test 14.4 { SELECT * FROM t1 } {1 2}

#-------------------------------------------------------------------------
# Check that "PRAGMA temp_store_directory" does not crash.
#
do_test 15.1 {
  catch { db close }
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  execsql {
    CREATE TABLE t1(a, b);
    INSERT INTO t1 VALUES(1, 2);
  }
  catchsql { PRAGMA temp_store_directory = '/tmp' }
  catchsql { PRAGMA temp_store_directory = '' }
  set {} {}
} {}

#-------------------------------------------------------------------------
# Check that if the specified parent VFS does not exists, 
# zipvfs_create_vfs() returns SQLITE_ERROR.
#
do_test 16.1 {
  catch { db close }
  catch { zip_unregister }
  list [catch { zip_register unknown 0 } msg] $msg
} {1 {SQL logic error}}
zip_register "" 0

#-------------------------------------------------------------------------
# Test a special type of corruption - a loop in free-slot b-tree pointers.
#
do_test 17.1 {
  catch { db close }
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  zip_control db main max_free 100000
  execsql {
    CREATE TABLE t1(a);
    INSERT INTO t1 VALUES(800);
    INSERT INTO t1 VALUES(799);
    INSERT INTO t1 SELECT (800-2-rowid) FROM t1;
    INSERT INTO t1 SELECT (800-4-rowid) FROM t1;
    INSERT INTO t1 SELECT (800-8-rowid) FROM t1;
    INSERT INTO t1 SELECT (800-16-rowid) FROM t1;
    INSERT INTO t1 SELECT (800-32-rowid) FROM t1;
    INSERT INTO t1 SELECT (800-64-rowid) FROM t1;
    INSERT INTO t1 SELECT (800-128-rowid) FROM t1;
    INSERT INTO t1 SELECT (800-256-rowid) FROM t1;
    INSERT INTO t1 SELECT (800-512-rowid) FROM t1;
    INSERT INTO t1 SELECT a FROM t1;
    DELETE FROM t1 WHERE rowid%2;
  }
  db_save

  # The number of free-slots in the database may vary slightly between SQLite
  # versions even if the zlib library version remains the same. This is 
  # because the version number written into the database header changes 
  # between SQLite versions, which in turn affects the compressibility of 
  # page 1 of the db.
  array set A [zip_control db main stat]
  expr {$A(nFreeSlot)>=35 && $A(nFreeSlot)<=38}
} {1}

do_test 17.2 {
  db close
  set iRoot [hexio_get_int [hexio_read test.db 104 4]]
  set height [hexio_read test.db [expr $iRoot+6] 2]
  expr $height>1
} {1}

do_test 17.3 {
  hexio_write test.db [expr $iRoot+11] [hexio_render_int32 $iRoot]
  sqlite3 db test.db -vfs zip
  catchsql {
    INSERT INTO t1 VALUES(randomblob(700));
    DELETE FROM t1 WHERE rowid = last_insert_rowid();
  }
} {1 {disk I/O error}}

foreach {tn iRootOff} {
  5 6
  7 8
} {
  do_test 17.$tn {
    db close
    db_restore
    hexio_write test.db [expr $iRoot+$iRootOff] 0000
    sqlite3 db test.db -vfs zip
    list [catch { zip_control db main integrity_check } msg] $msg
  } {1 {disk I/O error}}
}
db close
db_restore

# Search for the location of a key with the 'used' flag set.
#
proc get_int {hex} {
  set value 0
  while {[string length $hex]} {
    set next [string range $hex 0 1]
    set hex [string range $hex 2 end]
    set value [expr ($value<<8) + 0x$next]
  }
  return $value
}

# File $filename is a zipvfs database file. Return the byte offset within
# the file of the root of the free-slot b-tree structure. Or zero if there
# are no free slots.
#
# This command assumes that the root node lies within the first 2GiB of
# the named file.
#
proc fl_root_node_offset {filename} {
  hexio_get_int [hexio_read $filename 104 4]
}

proc fl_node_header {filename iOff nPayloadVar nHeightVar nEntryVar} {
  set data [hexio_read $filename [expr $iOff+4] 6]
  uplevel [list set $nPayloadVar [get_int [string range $data 0 3]]]
  uplevel [list set $nHeightVar [get_int [string range $data 4 7]]]
  uplevel [list set $nEntryVar [get_int [string range $data 8 11]]]
}

proc fl_node_rightchild {filename iOff} {
  get_int [hexio_read $filename [expr $iOff+10] 5]
}

proc fl_node_entryoffset {filename iOff iEntry} {
  fl_node_header $filename $iOff p h e
  if {$h>1} {
    set entryoff [expr 4+6+5+$iEntry*13]
  } else {
    set entryoff [expr 4+6+$iEntry*8]
  }
  return [expr $entryoff + $iOff]
}

proc fl_node_entry {filename iOff iEntry nSizeVar iOffVar iFlagVar} {
  set key_off [fl_node_entryoffset $filename $iOff $iEntry]
  set data [hexio_read $filename $key_off 8]

  set keyval [get_int $data]
  uplevel [list set $iFlagVar  [expr $keyval & 0x0001]]
  uplevel [list set $iOffVar   [expr ($keyval>>1) & 0x00FFFFFFFFFF]]
  uplevel [list set $nSizeVar  [expr ($keyval>>41)]]
}

proc fl_node_entrykey {filename iOff iEntry} {
  set key_off [fl_node_entryoffset $filename $iOff $iEntry]
  set data [hexio_read $filename $key_off 8]
  get_int $data
}

proc fl_node_entrychild {filename iOff iEntry} {
  get_int [hexio_read $filename [expr $iOff+10+5+($iEntry*13)+8] 5]
}

proc search_for_used_entry {filename iOff} {
  fl_node_header test.db $iOff p h n
  for {set i 0} {$i < $n} {incr i} {
    fl_node_entry test.db $iOff $i sz off flag
    if {$flag} { return [expr $iOff + 4 + 6 + ($h>1?5:0) + $i*($h>1?13:8)] }
    set res [
      search_for_used_entry $filename [fl_node_entrychild $filename $iOff $i]
    ]
    if {$res} { return $res }
  }
  if {$h>1} {
    set rc [fl_node_rightchild $filename $iOff]
    return [search_for_used_entry $filename $rc]
  }
  return 0
}

do_test 17.9 {
  set iUsedEntry [search_for_used_entry test.db $iRoot]
  hexio_write test.db [expr $iUsedEntry+7] 00
  sqlite3 db test.db -vfs zip
  list [catch { zip_control db main integrity_check } msg] $msg
} {1 {disk I/O error}}

do_test 17.10 {
  db close
  db_restore
  set val [get_int [hexio_read test.db [expr $iUsedEntry+6] 1]]
  incr val
  hexio_write test.db [expr $iUsedEntry+6] [format %.2X $val]
  sqlite3 db test.db -vfs zip
  list [catch { zip_control db main integrity_check } msg] $msg
} {1 {disk I/O error}}

do_test 17.11 {
  db close
  db_restore
  database_may_be_corrupt

  set iOff $iRoot
  while {1} {
    fl_node_header test.db $iOff p h n
    if {$h==1} break
    set iOff [fl_node_rightchild test.db $iOff]
  }
  if {$n<2} {error "test setup failed"}
  set cell1 [hexio_read test.db [expr $iOff + 4 + 6] 8]
  set cell2 [hexio_read test.db [expr $iOff + 4 + 6 + 8] 8]

  hexio_write test.db [expr $iOff + 4 + 6] $cell2
  #hexio_write test.db [expr $iOff + 4 + 6 + 8] $cell1

  sqlite3 db test.db -vfs zip
  list [catch { zip_control db main integrity_check } msg] $msg
} {1 {disk I/O error}}
do_test 17.12 {
  list [catch { zip_control db main compact } msg ] $msg
} {1 {disk I/O error}}

#do_test 17.13 {
#  db close
#  db_restore
#
#  set iOff $iRoot
#  while {1} {
#    fl_node_header test.db $iOff p h n
#    if {$h==1} break
#    set iOff [fl_node_entrychild test.db $iOff 0]
#  }
#  fl_node_entry test.db $iOff [expr $n-1] sz off flag
#  if {$flag} {error "test setup failed"}
#
#  hexio_write test.db [expr $iOff + 10 + ($n-1)*8] FFFF
#  sqlite3 db test.db -vfs zip
#  list [catch { zip_control db main integrity_check } msg] $msg
#} {1 {disk I/O error}}
#do_test 17.14 {
#  list [catch { zip_control db main compact } msg ] $msg
#} {1 {disk I/O error}}


#-------------------------------------------------------------------------
# Corruption case.
#
do_test 18.1 {
  catch { db close }
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  execsql {
    PRAGMA page_size = 1024;
    PRAGMA auto_vacuum = 0;
    BEGIN;
      CREATE TABLE t2(x);
      CREATE TABLE t1(x);
      INSERT INTO t1 VALUES(randomblob(30*1000));
    COMMIT;
    PRAGMA page_count;
  }
} {32}
do_test 18.2 {
  catch { db close }
  set off [get_int [hexio_read test.db 208 5]]
  hexio_write test.db $off 00000000
  sqlite3 db test.db -vfs zip
  catchsql { INSERT INTO t1 VALUES(randomblob(31*1000)) }
} {1 {disk I/O error}}
  

#-------------------------------------------------------------------------
# Run a couple of large insert statements with corruption-detection
# turned on. This is just to provide more testing for the integrity-check
# routines.
#
do_test 19.1 {
  catch { db close }
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  zip_control db main detect_corruption 1
  execsql {
    PRAGMA page_size = 1024;
    PRAGMA auto_vacuum = 0;
    PRAGMA cache_size = 1;
    BEGIN;
      CREATE TABLE t1(x);
      INSERT INTO t1 VALUES(randomblob(400));
      INSERT INTO t1 VALUES(randomblob(400));
      INSERT INTO t1 SELECT randomblob(400) FROM t1;
      INSERT INTO t1 SELECT randomblob(400) FROM t1;
      INSERT INTO t1 SELECT randomblob(400) FROM t1;
      INSERT INTO t1 SELECT randomblob(400) FROM t1;
    COMMIT;
    PRAGMA page_count;
  }
} {18}

#-------------------------------------------------------------------------
# Test zipvfs_destroy_vfs().
#
do_test 20.1 {
  catch { db close }
  zip_unregister
} {}
do_test 20.2 {
  zip_unregister
} {}
do_test 20.3 {
  zip_register "" 0
} {}


# Corruption case.
#
do_test 21.1 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  execsql {
    PRAGMA page_size = 1024;
    PRAGMA auto_vacuum = 0;
    BEGIN;
      CREATE TABLE t1(x);
      INSERT INTO t1 VALUES(randomblob(30*1010));
    COMMIT;
    CREATE TABLE t2(x);
    PRAGMA page_count;
  }
} {32}
do_test 21.2 {
  db close
  hexio_write test.db [expr {200 + 32*8}] 00000144
  sqlite3 db test.db -vfs zip
  catchsql { CREATE TABLE t3(x) }
} {0 {}}

# And another.
#
do_test 22.1 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  execsql {
    PRAGMA page_size = 1024;
    PRAGMA auto_vacuum = 0;
    BEGIN;
      CREATE TABLE t1(x);
      INSERT INTO t1 VALUES(randomblob(30*1010));
    COMMIT;
    CREATE TABLE t2(x);
    PRAGMA page_count;
  }
} {32}
do_test 22.2 {
  db close
  hexio_write test.db 40 1234567890
  sqlite3 db test.db -vfs zip
  list [catch {zip_control db main integrity_check} msg] $msg
} {1 {disk I/O error}}

do_test 23.1 {
  catch {db close}
  forcedelete test.db test.db2
  sqlite3 db test.db -vfs zip
  sqlite3 db2 test.db2

  execsql {
    PRAGMA page_size = 1024;
    PRAGMA auto_vacuum = 0;
    CREATE TABLE t1(x);
    CREATE TABLE t2(x);
    INSERT INTO t2 VALUES('x');
    BEGIN;
      INSERT INTO t2 VALUES(randomblob(30*1010));
      DROP TABLE t1;
  }
  execsql { DELETE FROM t2 WHERE oid=2 }
  execsql { COMMIT }

  db close
  sqlite3 db test.db -vfs zip
  sqlite3_backup B db2 main db main
  B step 10000
  B finish
} {SQLITE_OK}
do_test 23.2 {
  execsql { SELECT * FROM t2 } db2
} {x}
do_test 23.3 {
  db close
  db2 close
} {}

#-------------------------------------------------------------------------
# Corruption test case.
#
# This test creates a database and corrupts the compressed image of a 
# single page so that the xUncompress function succeeds (returns 0), but 
# the size of the uncompressed buffer is different from the user database
# page size.
#
do_test 24.0 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs rle
  populate_db_1 db
  db close

  find_page test.db 4 iOff nByte
  hexio_write test.db [expr {$iOff + 10}] 0000000000000000

  sqlite3 db test.db -vfs rle
  catchsql { PRAGMA integrity_check } 
} {1 {disk I/O error}}

#-------------------------------------------------------------------------
# Test the maximum slot size constraint. 
#
# If a call to xCompress returns a buffer larger than the largest allowable 
# slot size, then an error (SQLITE_ERROR) is returned to the users.
#
foreach {tn pgsz expected} {
  1     32768     {0 {}}
  2     65536     {1 {SQL logic error}}
} {
  do_test 25.$tn {
    catch {db close}
    forcedelete test.db
    sqlite3 db test.db -vfs padded

    execsql "PRAGMA page_size = $pgsz"
    catchsql { CREATE TABLE t1(x, y) }
  } $expected
}

#-------------------------------------------------------------------------
# Corruption test case.
#
# The nodes of the free-slot b-tree are themselves free-slots. When a new
# free-slot is required to create a new b-tree node, it is selected from
# the set of existing free-slots that are not already part of the b-tree.
# Since each node in the b-tree holds at least one key, and at least one
# node must hold more than one key for a new node to be required, there is
# always at least one free slot available for use. 
#
# This test case corrupts the database so that all free-slots are marked
# as used, even when they are not. Corruption is detected when zipvfs 
# attempts to allocate a b-tree node and discovers that there are no unused 
# free-slots.
#
proc gather_slots {iPg iOff nByte nPadding zDesc} {
  if {$iPg==0 && $zDesc!=""} {
    regexp {.*height=([01234567890]*), entries=([0123456789]*).*} $zDesc -> a b
    lappend ::slots $iOff $a $b
  }
}
proc mark_all_as_used {file iOff} {
  set height [hexio_get_int [hexio_read $file [expr $iOff+6] 2]]
  set nEntry [hexio_get_int [hexio_read $file [expr $iOff+8] 2]]
  set cellsize [expr {$height>1 ? 13 : 8}]
  set start    [expr {$iOff + 10 + ($height>1 ? 5 : 0)}]

  for {set i 0} {$i < $nEntry} {incr i} {
    set off [expr $start + $i*$cellsize + 7]
    set int [hexio_get_int [hexio_read $file $off 1]]
    set int [expr $int | 0x01]
    hexio_write $file $off [format %.2X $int]
  }
  if {$height>1} {
    set off [expr $iOff + 11]
    mark_all_as_used $file [hexio_get_int [hexio_read $file $off 4]]
  }
}
do_test 26.0 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  execsql {
    CREATE TABLE t1(a, b);
    INSERT INTO t1 VALUES(1, 2);
    INSERT INTO t1 VALUES(3, 4);
  }
} {}
do_test 26.1 {
  set rc [catch {
    while 1 {
      mark_all_as_used test.db [read_header_field test.db iFreeSlot]
      db close
      sqlite3 db test.db -vfs zip
      zip_control db main append_freeslot 40
    }
  } msg]
  list $rc $msg
} {1 {disk I/O error}}

#-------------------------------------------------------------------------
# Corruption test case.
#
# Modify a single "is-used" flag in the free-slot b-tree (so that a used
# free slot is marked as unused, or vice-versa). Check that the integrity
# check procedure detects this.
#
#   27.0: Mark an unused slot as used.
#   27.1: Mark a used slot as unused.
#
do_test 27.0 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  populate_db_1 db
  db close

  set iOff [read_header_field test.db iFreeSlot]

  set height [hexio_get_int [hexio_read test.db [expr $iOff+6] 2]]
  set nEntry [hexio_get_int [hexio_read test.db [expr $iOff+8] 2]]
  set cellsize [expr {$height>1 ? 13 : 8}]
  set start    [expr {$iOff + 10 + ($height>1 ? 5 : 0)}]

  for {set i 0} {$i < $nEntry} {incr i} {
    set off [expr $start + $i*$cellsize + 7]
    set int [hexio_get_int [hexio_read test.db $off 1]]
    if {($int & 0x01)==0} {
      set int [expr $int | 0x01]
      hexio_write test.db $off [format %.2X $int]
      break
    }
  }

  if {$i==$nEntry} {error "setup failed"}

  sqlite3 db test.db -vfs zip
  list [catch {zip_control db main integrity_check} msg] $msg
} {1 {disk I/O error}}

proc clear_one_flag {file iOff} {

  set height [hexio_get_int [hexio_read $file [expr $iOff+6] 2]]
  set nEntry [hexio_get_int [hexio_read $file [expr $iOff+8] 2]]
  set cellsize [expr {$height>1 ? 13 : 8}]
  set start    [expr {$iOff + 10 + ($height>1 ? 5 : 0)}]

  for {set i 0} {$i < $nEntry} {incr i} {
    set off [expr $start + $i*$cellsize + 7]
    set int [hexio_get_int [hexio_read $file $off 1]]
    if {($int & 0x01)==1} {
      set int [expr $int & 0xFE]
      hexio_write $file $off [format %.2X $int]
      return 1
    }

    if {$height>1} {
      incr off 2
      set ret [clear_one_flag $file [hexio_get_int [hexio_read $file $off 4]]]
      if {$ret} { return 1 }
    }
  }

  if {$height>1} {
    set off [expr $iOff+11]
    set ret [clear_one_flag $file [hexio_get_int [hexio_read $file $off 4]]]
    if {$ret} { return 1 }
  }

  return 0
}

do_test 27.1 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  populate_db_1 db
  db close

  set ret [clear_one_flag test.db [read_header_field test.db iFreeSlot]]
  if {$ret == 0} {error "setup failed"}

  sqlite3 db test.db -vfs zip
  list [catch {zip_control db main integrity_check} msg] $msg
} {1 {disk I/O error}}

#-------------------------------------------------------------------------
# Corruption test cases.
#
#   27.0: Set the nEntry field of a node header to 0.
#   27.1: Set the nEntry field of a node header to a value too large for
#         the payload size.
#   27.2: Set the iHeight field of a node header to 0.
#   27.3: Set the nPayload field of a node header to a value less than 35.
#
do_test 27.0 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  populate_db_1 db
  db close

  set iOff [read_header_field test.db iFreeSlot]
  hexio_write test.db [expr $iOff + 8] 0000

  sqlite3 db test.db -vfs zip

  catchsql { INSERT INTO t1 VALUES('x', 'y') }
} {1 {disk I/O error}}

do_test 27.1 {
  db close
  hexio_write test.db [expr $iOff + 8] 0FFF
  sqlite3 db test.db -vfs zip
  catchsql { INSERT INTO t1 VALUES('x', 'y') }
} {1 {disk I/O error}}

do_test 27.2 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  populate_db_1 db
  db close

  set iOff [read_header_field test.db iFreeSlot]
  hexio_write test.db [expr $iOff + 6] 0000

  sqlite3 db test.db -vfs zip

  catchsql { INSERT INTO t1 VALUES('x', 'y') }
} {1 {disk I/O error}}

do_test 27.3 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  populate_db_1 db
  db close

  set iOff [read_header_field test.db iFreeSlot]
  hexio_write test.db [expr $iOff + 4] 0010

  sqlite3 db test.db -vfs zip

  catchsql { INSERT INTO t1 VALUES('x', 'y') }
} {1 {disk I/O error}}
 
#-------------------------------------------------------------------------
# Corruption test cases.
#
# Test that the integrity-check file control detects the following 
# types of corruption:
#
#   28.1: Modify a key in the free-slot b-tree so that the payload size
#         is smaller than the minimum 35 bytes.
#
#   28.2: Modify a key so that it is smaller than one before it on a node.
#
#   28.3: Modify a key so that it is larger than the one in the nodes 
#         parent cell
#
do_test 28.0 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  populate_db_1 db
  db_save_and_close

  set iOff [read_header_field test.db iFreeSlot]

  set height [get_int [hexio_read test.db [expr $iOff+6] 2]]
  set nEntry [get_int [hexio_read test.db [expr $iOff+8] 2]]
  if {$height < 3} {error "setup failed"}
  if {$nEntry < 1} {error "setup failed"}

  set iParentKey [get_int [hexio_read test.db [expr $iOff+15] 8]]
  set iOff [get_int [hexio_read test.db [expr $iOff+15+8] 5]]

  set height [get_int [hexio_read test.db [expr $iOff+6] 2]]
  set nEntry [get_int [hexio_read test.db [expr $iOff+8] 2]]
  if {$nEntry==1} { hexio_write test.db [expr $iOff+8] 0002 }

  set iOff [expr $iOff+15]
  set iKey1 [get_int [hexio_read test.db $iOff 8]]
  set iOff [expr $iOff+13]
  set {} {}
} {}

foreach {tn iNewKey} [list                  \
  28.1    [expr (30<<41) + (200<<1)]        \
  28.2    [expr $iKey1 - 10]                \
  28.3    [expr $iParentKey + 10]           \
] {
  do_test $tn {
    hexio_write test.db $iOff [format %.16X $iNewKey]
    sqlite3 db test.db -vfs zip
    list [catch {zip_control db main integrity_check} msg] $msg
  } {1 {disk I/O error}}

  catch { db close }
}

#-------------------------------------------------------------------------
# Zipvfs header corruption test cases.
#
do_test 29.1 {
  catch {db close}
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  populate_db_1 db
  db_save_and_close
} {}

# Test that invalid values in the page-size field are detected. At one 
# point if the page-size field contained a zero a division-by-zero exception
# could be thrown.
#
foreach {tn pgsz} {
  1     0 
  2   256 
  3   513 
  4   130172 
  5   130171 
} {
  do_test 29.2.$tn {
    db_restore
    write_header_field test.db pgsz $pgsz
    sqlite3 db test.db -vfs zip
    catchsql { SELECT count(*) FROM t1 }
  } {1 {disk I/O error}}
}

#-------------------------------------------------------------------------
# Test that if secure-delete mode is turned on, free-list leaves do not
# occupy any slot in a zipvfs file.
#
proc xStructure {pgno args} { if {$pgno==0} {incr ::nFree} }
proc free_list_size {} {
  set ::nFree 0
  zip_control db main structure xStructure
  set ::nFree
}
do_test 30.0 {
  catch { db close }
  forcedelete test.db
  sqlite3 db test.db -vfs zip
  populate_db_1 db
  db_save_and_close
} {}

do_test 30.1 {
  db_restore
  sqlite3 db test.db -vfs zip
  free_list_size
} {99}

do_test 30.2 {
  execsql { PRAGMA secure_delete = 0 }
  execsql { DELETE FROM t1 }
  free_list_size
} {99}

do_test 30.3 {
  db close
  db_restore
  sqlite3 db test.db -vfs zip
  execsql { PRAGMA secure_delete = 1 }
  execsql { DELETE FROM t1 }
  free_list_size
} {109}

# This is a helper proc used by [fl_iterate]. Refer to comments above
# that command for details.
#
proc fl_iterate_children {zFile offset arrayname script} {
  upvar $arrayname A
  set saved_parent_key $A(parent_key)

  fl_node_header $zFile $offset nPayload nHeight nEntry
  for {set i 0} {$i < $nEntry} {incr i} {
    fl_node_entry $zFile $offset $i A(nSize) A(iOff) A(iFlag)

    set A(key)        [fl_node_entrykey $zFile $offset $i]
    set A(key_offset) [fl_node_entryoffset $zFile $offset $i]
    uplevel $script

    if {$nHeight>1} {
      set child [fl_node_entrychild $zFile $offset $i]
      set A(parent_key) $A(key)
      uplevel [list fl_iterate_children $zFile $child $arrayname $script]
      set A(parent_key) $saved_parent_key
    }
  }

  if {$nHeight>1} {
    set A(parent_key) 0
    set child [fl_node_rightchild $zFile $offset]
    uplevel [list fl_iterate_children $zFile $child $arrayname $script]
    set A(parent_key) $saved_parent_key
  }
}

# Iterate through all free-slots in the free-slot b-tree, in tree order.
# For each free-slot, evaluate the $script argument as a Tcl script. Before
# doing so, populate array variable $arrayname as follows:
#
#   A(iOff)            Byte offset of free-slot within file.
#   A(nSize)           Size of free-slot in bytes within file. 
#   A(iFlag)           True if slot is part of b-tree, false otherwise.
#
# the three values above are the components of the 8-byte b-tree key value
# (see documentation in zipvfs.c for details). The location of the key within
# the file is:
#
#   A(key)             The three values above in 8-byte key form.
#   A(key_offset)      Byte offset within file of 8-byte key.
#   A(parent_key)      Key from parent node (or 0 if none).
#
proc fl_iterate {zFile arrayname script} {
  upvar $arrayname A
  set root [fl_root_node_offset $zFile]
  set A(parent_key) 0
  uplevel [list fl_iterate_children $zFile $root $arrayname $script]
}


#-------------------------------------------------------------------------
# Test out of order entries in free-list leaf nodes are detected by
# the integrity-check file-control.
#
do_test 31.0 {
  catch { db close }
  forcedelete test.db
  sqlite3 db test.db -vfs zip

  execsql {
    CREATE TABLE t1(x);
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    INSERT INTO t1 VALUES(randomblob(900));
    DELETE FROM t1 WHERE rowid%2;
  }
  db_save_and_close
} {}

catch { array unset A }
set slots [list]
set tn 0
fl_iterate test.db A { lappend slots [array get A] }

# Loop through all keys in the free-slot b-tree. For each key that is part
# of a node that is not the root node or the right-hand child of its parent,
# modify the nSize field of the key so that it is one byte larger than the
# nSize field in the key within the parent node (the key that all keys on
# the node are supposed to be smaller than). Check that this is detected
# by integrity-check.
#
foreach slot $slots {
  incr tn
  array set A $slot
  if {$A(parent_key)>0} {
    set newval [expr {
      ($A(key) & 0x00001FFFFFFFFFF)
        + ((($A(parent_key) >> 41) + 1) << 41)
    }]
    hexio_write test.db $A(key_offset) [format %.16x $newval]

    do_test 31.$tn {
      sqlite3 db test.db -vfs zip
      list [catch {zip_control db main integrity_check} msg] $msg
    } {1 {disk I/O error}}
    db close
    db_restore
  }
}

#-------------------------------------------------------------------------
# Test that the integrity-check detects cases where the size of an entry as
# indicated by the lookup table at the start of the file is different
# from the size as reported by the slot header within the body of the file.
#

set slots [list]
proc cb {pgno iOff nByte nPadding desc} {
  global slots
  if {$pgno!=0} {
    lappend slots [list pgno $pgno iOff $iOff nByte $nByte nPadding $nPadding]
  }
}
sqlite3 db test.db -vfs zip
zip_control db main structure cb
db close

proc write_lookup_slot {filename pgno iOff nByte nPadding} {
  set hex [format %.10x $iOff]
  append hex [format %.6x [expr ($nByte<<7) + $nPadding]]
  hexio_write $filename [expr 200 + 8*($pgno-1)] $hex
}

set tn 0
catch { array unset A }
foreach slot $slots {
  incr tn
  array set A $slot

  write_lookup_slot test.db $A(pgno) $A(iOff) $A(nByte) $A(nPadding)
  do_test 32.$tn.0 {
    sqlite3 db test.db -vfs zip
    list [catch {zip_control db main integrity_check} msg] $msg
  } {0 {}}
  db close
  db_restore

  write_lookup_slot test.db $A(pgno) $A(iOff) [expr $A(nByte)+1] $A(nPadding)
  do_test 32.$tn.1 {
    sqlite3 db test.db -vfs zip
    breakpoint
    list [catch {zip_control db main integrity_check} msg] $msg
  } {1 {disk I/O error}}
  db close
  db_restore

  write_lookup_slot test.db $A(pgno) $A(iOff) $A(nByte) [expr $A(nPadding)+1]
  do_test 32.$tn.2 {
    sqlite3 db test.db -vfs zip
    list [catch {zip_control db main integrity_check} msg] $msg
  } {1 {disk I/O error}}
  db close
  db_restore
}

#-------------------------------------------------------------------------
# Test that the date/time functions work with zipvfs.
#
do_test 33.1 {
  sqlite3 db test.db -vfs zip
  execsql { SELECT date('now') IS NOT NULL }
} {1}

catch { db close }
zip_unregister
rle_unregister
noop_unregister
padded_unregister
finish_test
